use std::fs;
use std::fs::File;
use std::io::prelude::*;
use ttrpc_codegen::Codegen;
use ttrpc_codegen::{Customize, ProtobufCustomize};

fn main() {
    let mut protos = fs::read_dir("protos")
        .expect("Could not read 'protos/common' directory")
        .map(|res| {
            res.map(|e| e.path())
                .expect("Could not get path of proto files")
        })
        .collect::<Vec<_>>();
    protos.retain(|p| !p.is_dir());

    let protos_async = fs::read_dir("protos/async")
        .expect("Could not read 'protos/async' directory")
        .map(|res| {
            res.map(|e| e.path())
                .expect("Could not get path of proto files")
        })
        .collect::<Vec<_>>();
    let protos_sync = fs::read_dir("protos/sync")
        .expect("Could not read 'protos/sync' directory")
        .map(|res| {
            res.map(|e| e.path())
                .expect("Could not get path of proto files")
        })
        .collect::<Vec<_>>();

    // Sort entries
    protos.sort();

    // Create the lib.rs file and add all the auto-generated mods
    let header = b"// This is auto-generated by build.rs\n\n\
    pub mod asynchronous;\n\
    pub use asynchronous as r#async;\n\
    pub mod sync;\n\n";

    let mut libf = File::create("src/lib.rs").expect("Could not open crate's lib file");
    libf.write(header)
        .expect("Could not write in crate's lib.rs");
    let mut libf_async =
        File::create("src/asynchronous/mod.rs").expect("Could not open crate's async lib file");
    libf_async
        .write(b"// This is auto-generated by build.rs\n\n#![allow(unused_imports)]\n\n")
        .expect("Could not write in crate's async/mod.rs");
    let mut libf_sync =
        File::create("src/sync/mod.rs").expect("Could not open crate's sync lib file");
    libf_sync
        .write(b"// This is auto-generated by build.rs\n\n#![allow(unused_imports)]\n\n")
        .expect("Could not write in crate's sync/mod.rs");

    for proto in protos.iter() {
        // Re-run compilation every time the proto file changes
        println!("cargo:rerun-if-changed={:?}", &proto);

        // Strip path prefix and .proto suffix
        let mod_name = proto
            .strip_prefix("protos/")
            .expect(&format!("Error stripping file {:?}", proto))
            .with_extension("");

        libf.write_all(&format!("pub mod {};\n", mod_name.to_str().unwrap()).as_bytes())
            .expect("Could not write mod in crate's lib file");
        libf_async
            .write_all(&format!("pub use crate::{};\n", mod_name.to_str().unwrap()).as_bytes())
            .expect("Could not write mod in crate's async mod file");
        libf_sync
            .write_all(&format!("pub use crate::{};\n", mod_name.to_str().unwrap()).as_bytes())
            .expect("Could not write mod in crate's async mod file");
    }

    for proto in protos_async.iter() {
        // Re-run compilation every time the proto file changes
        println!("cargo:rerun-if-changed={:?}", &proto);

        // Strip path prefix and .proto suffix
        let mod_name = proto
            .strip_prefix("protos/async")
            .expect(&format!("Error stripping file {:?}", proto))
            .with_extension("");

        libf_async
            .write_all(&format!("pub mod {};\n", mod_name.to_str().unwrap()).as_bytes())
            .expect("Could not write mod in crate's async mod file");
    }

    for proto in protos_sync.iter() {
        // Re-run compilation every time the proto file changes
        println!("cargo:rerun-if-changed={:?}", &proto);

        // Strip path prefix and .proto suffix
        let mod_name = proto
            .strip_prefix("protos/sync")
            .expect(&format!("Error stripping file {:?}", proto))
            .with_extension("");

        libf_sync
            .write_all(&format!("pub mod {};\n", mod_name.to_str().unwrap()).as_bytes())
            .expect("Could not write mod in crate's sync mod file");
    }

    // Add as well the ttrpc file
    libf_async
        .write_all(b"pub mod agent_ttrpc;\n")
        .expect("Could not write mod in crate's async/mod.rs file");
    libf_sync
        .write_all(b"pub mod agent_ttrpc;\n")
        .expect("Could not write mod in crate's sync/mod.rs file");

    let protobuf_customized = ProtobufCustomize::default().gen_mod_rs(false);
    Codegen::new()
        .out_dir("src")
        .inputs(&protos)
        .include("protos")
        .rust_protobuf()
        .customize(Customize {
            async_all: true,
            ..Default::default()
        })
        .rust_protobuf_customize(protobuf_customized.clone())
        .run()
        .expect("Async protocol generation failed.");

    Codegen::new()
        .out_dir("src/asynchronous")
        .inputs(&protos_async)
        .includes(&["protos", "protos/async"])
        .rust_protobuf()
        .customize(Customize {
            async_all: true,
            ..Default::default()
        })
        .rust_protobuf_customize(protobuf_customized.clone())
        .run()
        .expect("Async protocol generation failed.");

    Codegen::new()
        .out_dir("src/sync")
        .inputs(&protos_sync)
        .includes(&["protos", "protos/sync"])
        .rust_protobuf()
        .customize(Customize {
            ..Default::default()
        })
        .rust_protobuf_customize(protobuf_customized.clone())
        .run()
        .expect("Sync protocol generation failed.");
}
