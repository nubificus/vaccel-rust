// This file is generated by ttrpc-compiler 0.6.2. Do not edit
// @generated

#![cfg_attr(rustfmt, rustfmt_skip)]
#![allow(unknown_lints)]
#![allow(clipto_camel_casepy)]
#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
#![allow(clippy::all)]
use protobuf::{CodedInputStream, CodedOutputStream, Message};
use std::collections::HashMap;
use std::sync::Arc;
use async_trait::async_trait;

#[derive(Clone)]
pub struct VaccelAgentClient {
    client: ::ttrpc::r#async::Client,
}

impl VaccelAgentClient {
    pub fn new(client: ::ttrpc::r#async::Client) -> Self {
        VaccelAgentClient {
            client: client,
        }
    }

    pub async fn create_session(&self, ctx: ttrpc::context::Context, req: &super::session::CreateSessionRequest) -> ::ttrpc::Result<super::session::CreateSessionResponse> {
        let mut cres = super::session::CreateSessionResponse::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "CreateSession", cres);
    }

    pub async fn update_session(&self, ctx: ttrpc::context::Context, req: &super::session::UpdateSessionRequest) -> ::ttrpc::Result<super::agent::VaccelEmpty> {
        let mut cres = super::agent::VaccelEmpty::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "UpdateSession", cres);
    }

    pub async fn destroy_session(&self, ctx: ttrpc::context::Context, req: &super::session::DestroySessionRequest) -> ::ttrpc::Result<super::agent::VaccelEmpty> {
        let mut cres = super::agent::VaccelEmpty::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "DestroySession", cres);
    }

    pub async fn create_resource(&self, ctx: ttrpc::context::Context, req: &super::resources::CreateResourceRequest) -> ::ttrpc::Result<super::resources::CreateResourceResponse> {
        let mut cres = super::resources::CreateResourceResponse::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "CreateResource", cres);
    }

    pub async fn register_resource(&self, ctx: ttrpc::context::Context, req: &super::resources::RegisterResourceRequest) -> ::ttrpc::Result<super::agent::VaccelEmpty> {
        let mut cres = super::agent::VaccelEmpty::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "RegisterResource", cres);
    }

    pub async fn unregister_resource(&self, ctx: ttrpc::context::Context, req: &super::resources::UnregisterResourceRequest) -> ::ttrpc::Result<super::agent::VaccelEmpty> {
        let mut cres = super::agent::VaccelEmpty::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "UnregisterResource", cres);
    }

    pub async fn destroy_resource(&self, ctx: ttrpc::context::Context, req: &super::resources::DestroyResourceRequest) -> ::ttrpc::Result<super::agent::VaccelEmpty> {
        let mut cres = super::agent::VaccelEmpty::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "DestroyResource", cres);
    }

    pub async fn image_classification(&self, ctx: ttrpc::context::Context, req: &super::image::ImageClassificationRequest) -> ::ttrpc::Result<super::image::ImageClassificationResponse> {
        let mut cres = super::image::ImageClassificationResponse::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "ImageClassification", cres);
    }

    pub async fn tensorflow_model_load(&self, ctx: ttrpc::context::Context, req: &super::tensorflow::TensorflowModelLoadRequest) -> ::ttrpc::Result<super::tensorflow::TensorflowModelLoadResponse> {
        let mut cres = super::tensorflow::TensorflowModelLoadResponse::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "TensorflowModelLoad", cres);
    }

    pub async fn tensorflow_model_unload(&self, ctx: ttrpc::context::Context, req: &super::tensorflow::TensorflowModelUnloadRequest) -> ::ttrpc::Result<super::tensorflow::TensorflowModelUnloadResponse> {
        let mut cres = super::tensorflow::TensorflowModelUnloadResponse::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "TensorflowModelUnload", cres);
    }

    pub async fn tensorflow_model_run(&self, ctx: ttrpc::context::Context, req: &super::tensorflow::TensorflowModelRunRequest) -> ::ttrpc::Result<super::tensorflow::TensorflowModelRunResponse> {
        let mut cres = super::tensorflow::TensorflowModelRunResponse::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "TensorflowModelRun", cres);
    }

    pub async fn torch_jitload_forward(&self, ctx: ttrpc::context::Context, req: &super::torch::TorchJitloadForwardRequest) -> ::ttrpc::Result<super::torch::TorchJitloadForwardResponse> {
        let mut cres = super::torch::TorchJitloadForwardResponse::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "TorchJitloadForward", cres);
    }

    pub async fn genop(&self, ctx: ttrpc::context::Context, req: &super::genop::GenopRequest) -> ::ttrpc::Result<super::genop::GenopResponse> {
        let mut cres = super::genop::GenopResponse::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "Genop", cres);
    }

    pub async fn genop_stream(&self, ctx: ttrpc::context::Context) -> ::ttrpc::Result<::ttrpc::r#async::ClientStreamSender<super::genop::GenopRequest, super::genop::GenopResponse>> {
        ::ttrpc::async_client_stream_send!(self, ctx, "vaccel.VaccelAgent", "GenopStream");
    }

    pub async fn get_timers(&self, ctx: ttrpc::context::Context, req: &super::profiling::ProfilingRequest) -> ::ttrpc::Result<super::profiling::ProfilingResponse> {
        let mut cres = super::profiling::ProfilingResponse::new();
        ::ttrpc::async_client_request!(self, ctx, req, "vaccel.VaccelAgent", "GetTimers", cres);
    }
}

struct CreateSessionMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for CreateSessionMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, session, CreateSessionRequest, create_session);
    }
}

struct UpdateSessionMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for UpdateSessionMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, session, UpdateSessionRequest, update_session);
    }
}

struct DestroySessionMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for DestroySessionMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, session, DestroySessionRequest, destroy_session);
    }
}

struct CreateResourceMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for CreateResourceMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, resources, CreateResourceRequest, create_resource);
    }
}

struct RegisterResourceMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for RegisterResourceMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, resources, RegisterResourceRequest, register_resource);
    }
}

struct UnregisterResourceMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for UnregisterResourceMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, resources, UnregisterResourceRequest, unregister_resource);
    }
}

struct DestroyResourceMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for DestroyResourceMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, resources, DestroyResourceRequest, destroy_resource);
    }
}

struct ImageClassificationMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for ImageClassificationMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, image, ImageClassificationRequest, image_classification);
    }
}

struct TensorflowModelLoadMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for TensorflowModelLoadMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, tensorflow, TensorflowModelLoadRequest, tensorflow_model_load);
    }
}

struct TensorflowModelUnloadMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for TensorflowModelUnloadMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, tensorflow, TensorflowModelUnloadRequest, tensorflow_model_unload);
    }
}

struct TensorflowModelRunMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for TensorflowModelRunMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, tensorflow, TensorflowModelRunRequest, tensorflow_model_run);
    }
}

struct TorchJitloadForwardMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for TorchJitloadForwardMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, torch, TorchJitloadForwardRequest, torch_jitload_forward);
    }
}

struct GenopMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for GenopMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, genop, GenopRequest, genop);
    }
}

struct GenopStreamMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::StreamHandler for GenopStreamMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, inner: ::ttrpc::r#async::StreamInner) -> ::ttrpc::Result<Option<::ttrpc::Response>> {
        ::ttrpc::async_client_streamimg_handler!(self, ctx, inner, genop_stream);
    }
}

struct GetTimersMethod {
    service: Arc<Box<dyn VaccelAgent + Send + Sync>>,
}

#[async_trait]
impl ::ttrpc::r#async::MethodHandler for GetTimersMethod {
    async fn handler(&self, ctx: ::ttrpc::r#async::TtrpcContext, req: ::ttrpc::Request) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, profiling, ProfilingRequest, get_timers);
    }
}

#[async_trait]
pub trait VaccelAgent: Sync {
    async fn create_session(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::session::CreateSessionRequest) -> ::ttrpc::Result<super::session::CreateSessionResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/CreateSession is not supported".to_string())))
    }
    async fn update_session(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::session::UpdateSessionRequest) -> ::ttrpc::Result<super::agent::VaccelEmpty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/UpdateSession is not supported".to_string())))
    }
    async fn destroy_session(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::session::DestroySessionRequest) -> ::ttrpc::Result<super::agent::VaccelEmpty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/DestroySession is not supported".to_string())))
    }
    async fn create_resource(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::resources::CreateResourceRequest) -> ::ttrpc::Result<super::resources::CreateResourceResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/CreateResource is not supported".to_string())))
    }
    async fn register_resource(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::resources::RegisterResourceRequest) -> ::ttrpc::Result<super::agent::VaccelEmpty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/RegisterResource is not supported".to_string())))
    }
    async fn unregister_resource(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::resources::UnregisterResourceRequest) -> ::ttrpc::Result<super::agent::VaccelEmpty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/UnregisterResource is not supported".to_string())))
    }
    async fn destroy_resource(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::resources::DestroyResourceRequest) -> ::ttrpc::Result<super::agent::VaccelEmpty> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/DestroyResource is not supported".to_string())))
    }
    async fn image_classification(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::image::ImageClassificationRequest) -> ::ttrpc::Result<super::image::ImageClassificationResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/ImageClassification is not supported".to_string())))
    }
    async fn tensorflow_model_load(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::tensorflow::TensorflowModelLoadRequest) -> ::ttrpc::Result<super::tensorflow::TensorflowModelLoadResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/TensorflowModelLoad is not supported".to_string())))
    }
    async fn tensorflow_model_unload(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::tensorflow::TensorflowModelUnloadRequest) -> ::ttrpc::Result<super::tensorflow::TensorflowModelUnloadResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/TensorflowModelUnload is not supported".to_string())))
    }
    async fn tensorflow_model_run(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::tensorflow::TensorflowModelRunRequest) -> ::ttrpc::Result<super::tensorflow::TensorflowModelRunResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/TensorflowModelRun is not supported".to_string())))
    }
    async fn torch_jitload_forward(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::torch::TorchJitloadForwardRequest) -> ::ttrpc::Result<super::torch::TorchJitloadForwardResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/TorchJitloadForward is not supported".to_string())))
    }
    async fn genop(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::genop::GenopRequest) -> ::ttrpc::Result<super::genop::GenopResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/Genop is not supported".to_string())))
    }
    async fn genop_stream(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: ::ttrpc::r#async::ServerStreamReceiver<super::genop::GenopRequest>) -> ::ttrpc::Result<super::genop::GenopResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/GenopStream is not supported".to_string())))
    }
    async fn get_timers(&self, _ctx: &::ttrpc::r#async::TtrpcContext, _: super::profiling::ProfilingRequest) -> ::ttrpc::Result<super::profiling::ProfilingResponse> {
        Err(::ttrpc::Error::RpcStatus(::ttrpc::get_status(::ttrpc::Code::NOT_FOUND, "/vaccel.VaccelAgent/GetTimers is not supported".to_string())))
    }
}

pub fn create_vaccel_agent(service: Arc<Box<dyn VaccelAgent + Send + Sync>>) -> HashMap<String, ::ttrpc::r#async::Service> {
    let mut ret = HashMap::new();
    let mut methods = HashMap::new();
    let mut streams = HashMap::new();

    methods.insert("CreateSession".to_string(),
                    Box::new(CreateSessionMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("UpdateSession".to_string(),
                    Box::new(UpdateSessionMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("DestroySession".to_string(),
                    Box::new(DestroySessionMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("CreateResource".to_string(),
                    Box::new(CreateResourceMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("RegisterResource".to_string(),
                    Box::new(RegisterResourceMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("UnregisterResource".to_string(),
                    Box::new(UnregisterResourceMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("DestroyResource".to_string(),
                    Box::new(DestroyResourceMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("ImageClassification".to_string(),
                    Box::new(ImageClassificationMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("TensorflowModelLoad".to_string(),
                    Box::new(TensorflowModelLoadMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("TensorflowModelUnload".to_string(),
                    Box::new(TensorflowModelUnloadMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("TensorflowModelRun".to_string(),
                    Box::new(TensorflowModelRunMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("TorchJitloadForward".to_string(),
                    Box::new(TorchJitloadForwardMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    methods.insert("Genop".to_string(),
                    Box::new(GenopMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    streams.insert("GenopStream".to_string(),
                    Arc::new(GenopStreamMethod{service: service.clone()}) as Arc<dyn ::ttrpc::r#async::StreamHandler + Send + Sync>);

    methods.insert("GetTimers".to_string(),
                    Box::new(GetTimersMethod{service: service.clone()}) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>);

    ret.insert("vaccel.VaccelAgent".to_string(), ::ttrpc::r#async::Service{ methods, streams });
    ret
}
