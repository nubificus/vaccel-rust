// SPDX-License-Identifier: Apache-2.0

use std::{env, fs, fs::File, io::prelude::*};
use ttrpc_codegen::Codegen;
use ttrpc_codegen::{Customize, ProtobufCustomize};

fn main() {
    let mut protos = fs::read_dir("protos")
        .expect("Could not read 'protos/common' directory")
        .map(|res| {
            res.map(|e| e.path())
                .expect("Could not get path of proto files")
        })
        .collect::<Vec<_>>();
    protos.retain(|p| !p.is_dir());

    let protos_async = fs::read_dir("protos/async")
        .expect("Could not read 'protos/async' directory")
        .map(|res| {
            res.map(|e| e.path())
                .expect("Could not get path of proto files")
        })
        .collect::<Vec<_>>();
    let protos_sync = fs::read_dir("protos/sync")
        .expect("Could not read 'protos/sync' directory")
        .map(|res| {
            res.map(|e| e.path())
                .expect("Could not get path of proto files")
        })
        .collect::<Vec<_>>();

    // Sort entries
    protos.sort();

    let out_dir = env::var("OUT_DIR").expect("Could not read OUT_DIR");

    // Create the lib.rs file and add all the auto-generated mods
    let header = "// SPDX-License-Identifier: Apache-2.0\n\n\
    // This file is generated by build.rs. Do not edit\n\n";
    let header_mods = "pub mod asynchronous;\n\
    pub use asynchronous as r#async;\n\
    pub mod sync;\n\n";
    let header_unused = "#![allow(unused_imports)]\n\n";

    let mut libf =
        File::create(format!("{}/lib.rs", out_dir)).expect("Could not open crate's lib file");
    write!(libf, "{}{}", header, header_mods).expect("Could not write in crate's lib.rs");

    fs::create_dir_all(format!("{}/asynchronous", out_dir))
        .unwrap_or_else(|_| panic!("Could not create dir {}/asynchronous", out_dir));
    let mut libf_async = File::create(format!("{}/asynchronous/mod.rs", out_dir))
        .expect("Could not open crate's async lib file");
    write!(libf_async, "{}{}", header, header_unused)
        .expect("Could not write in crate's async/mod.rs");

    fs::create_dir_all(format!("{}/sync", out_dir))
        .unwrap_or_else(|_| panic!("Could not create dir {}/sync", out_dir));
    let mut libf_sync = File::create(format!("{}/sync/mod.rs", out_dir))
        .expect("Could not open crate's sync lib file");
    write!(libf_sync, "{}{}", header, header_unused)
        .expect("Could not write in crate's sync/mod.rs");

    for proto in protos.iter() {
        // Re-run compilation every time the proto file changes
        println!("cargo:rerun-if-changed={:?}", &proto);

        // Strip path prefix and .proto suffix
        let mod_name = proto
            .strip_prefix("protos/")
            .unwrap_or_else(|_| panic!("Error stripping file {:?}", proto))
            .with_extension("");

        libf.write_all(format!("pub mod {};\n", mod_name.to_str().unwrap()).as_bytes())
            .expect("Could not write mod in crate's lib file");
        libf_async
            .write_all(format!("pub use crate::{};\n", mod_name.to_str().unwrap()).as_bytes())
            .expect("Could not write mod in crate's async mod file");
        libf_sync
            .write_all(format!("pub use crate::{};\n", mod_name.to_str().unwrap()).as_bytes())
            .expect("Could not write mod in crate's async mod file");
    }

    for proto in protos_async.iter() {
        // Re-run compilation every time the proto file changes
        println!("cargo:rerun-if-changed={:?}", &proto);

        // Strip path prefix and .proto suffix
        let mod_name = proto
            .strip_prefix("protos/async")
            .unwrap_or_else(|_| panic!("Error stripping file {:?}", proto))
            .with_extension("");

        libf_async
            .write_all(format!("pub mod {};\n", mod_name.to_str().unwrap()).as_bytes())
            .expect("Could not write mod in crate's async mod file");
    }

    for proto in protos_sync.iter() {
        // Re-run compilation every time the proto file changes
        println!("cargo:rerun-if-changed={:?}", &proto);

        // Strip path prefix and .proto suffix
        let mod_name = proto
            .strip_prefix("protos/sync")
            .unwrap_or_else(|_| panic!("Error stripping file {:?}", proto))
            .with_extension("");

        libf_sync
            .write_all(format!("pub mod {};\n", mod_name.to_str().unwrap()).as_bytes())
            .expect("Could not write mod in crate's sync mod file");
    }

    // Add as well the ttrpc file
    libf_async
        .write_all(b"pub mod agent_ttrpc;\n")
        .expect("Could not write mod in crate's async/mod.rs file");
    libf_sync
        .write_all(b"pub mod agent_ttrpc;\n")
        .expect("Could not write mod in crate's sync/mod.rs file");

    let protobuf_customized = ProtobufCustomize::default().gen_mod_rs(false);
    Codegen::new()
        .out_dir(out_dir.clone())
        .inputs(&protos)
        .include("protos")
        .rust_protobuf()
        .customize(Customize {
            async_all: true,
            ..Default::default()
        })
        .rust_protobuf_customize(protobuf_customized.clone())
        .run()
        .expect("Common protocol generation failed.");

    Codegen::new()
        .out_dir(format!("{}/asynchronous", out_dir))
        .inputs(&protos_async)
        .includes(["protos", "protos/async"])
        .rust_protobuf()
        .customize(Customize {
            async_all: true,
            ..Default::default()
        })
        .rust_protobuf_customize(protobuf_customized.clone())
        .run()
        .expect("Async protocol generation failed.");

    Codegen::new()
        .out_dir(format!("{}/sync", out_dir))
        .inputs(&protos_sync)
        .includes(["protos", "protos/sync"])
        .rust_protobuf()
        .customize(Customize {
            ..Default::default()
        })
        .rust_protobuf_customize(protobuf_customized)
        .run()
        .expect("Sync protocol generation failed.");
}
